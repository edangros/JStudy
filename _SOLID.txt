S : Single Responsibility Principle(단일 책임 원칙)    *****제일 중요!!!!!! 이게 지켜지지 않으면 다른 원칙은 지킬수도 없음
모든 클래스는 한 가지 책임만 져야 한다
->어떠한 한 가지 기능이 여러 클래스에 쪼개져 있으면 안된다
+ 한 가지 클래스가 두 가지 이상의 기능을 지녀서도 안된다

-모든 무기와 관련된 사항은 Weapon 클래스가 해결해야 한다.
--Weapon 클래스가 Weapon_base, Weapon_Swing 등으로 쪼개져있으면 안된다.
--Weapon 클래스가 무기와 함께 무기를 쥐고 있는 캐릭터까지 통제해서는 안된다. 캐릭터는 Character 클래스가 모든 전권을 쥐어야 한다.

-이게 이루어지지 않았다면 '객체 지향'이라 할 수 없다.

<상속과 S원칙>
'모든 공통된 부분'은 부모가 가져야 한다
'모든 다른 부분'은 각 자식 개체가 가져야 한다
-다시 말해 부모 클래스는 자신은 사용하지 않는 부분을 특정 자식 클래스가 가진다고 포함해서는 안된다.
 ('모든 자식 클래스'가 가진다면 부모 클래스가 포함하고 있어야 한다)  -> 아래의 I원칙과 관련
-또한 자식 클래스는 공통된 부분들을 각자 포함해서는 안된다
-ex)조류 클래스 아래에 팽귄과 독수리가 있다면
- 두 새의 공통점인 날개, 다리, 머리,눈 등은 모두 '조류' 클래스가 가지고 있어야 한다.
- '색상', '깃털모양' 등 두 클래스에서 구현 자체는 다르나 공통된 부분은 조류 클래스에서 선언하고 구현은 각 클래스에 맡긴다
- 독수리의 '비행', 팽귄의 '수영'이 있으나 독수리에는 '수영'이 없고 팽귄에는 '비행'이 없으므로 이는 자식 클래스에서 선언한다

----이러면 아래와 같은 효과를 얻을 수 있는데
-독수리의 비행에 문제가 있다면 이건 독수리 클래스의 '비행' 메서드 문제임을 바로 알 수 있다. 팽귄의 수영 또한 마찬가지이다.
-팽귄은 정상적으로 만들어지는데 독수리는 머리가 두개가 되어 만들어진다면, 일반적으로 독수리 클래스가 문제가 있을 거라 생각하고
 독수리 클래스를 가지고 머리를 낑낑 싸맨 뒤에야 조류 클래스에 문제가 있는지 찾아보겠지만, SRP원칙에 따라 '머리'의 전권을
 조류 클래스가 쥐고 있음을 인지하고 있다면, 조류 클래스의 어떤 문제가 독수리의 머리를 두개로 만든다는걸 확인하고 바로 조치할 수
 있다.


O : Open-Close Principle(개방 폐쇄 원칙)
모든 클래스는 확장에 있어 개방적이고 수정에 있어 폐쇄되어 있어야 한다.

<public vs Getter/Setter>
-클래스의 getter, setter를 통해 기능을 추가,변경하는 것은 자유로워야 한다.
-클래스의 프로퍼티(맴버 변수 중 캡슐화된 경우를 가리키기도 하는데, 맴버 변수 자체를 가리키는 말이기도 함)는 수정되지 않는다.

<상속과 O원칙>
-클래스의 기능 추가/변경은 어느때나 상속이나 컴포넌트 모델(클래스가 온갖 잡동사니를 들었다가 놓았다가 하는 모델)을 통해 가능해야 한다.
-클래스의 본질 자체가 수정되어서는 안된다.
-클래스를 추가할 때, 기능을 확장할 수 있게 디자인하되, 클래스가 수행할 수 있는 일 자체가 바뀌어서는 안된다.

-Bow 클래스는 기능이 확장되어 Attack시 Arrow를 생성하여 발사한다.
--하지만 Bow 클래스가 Attack을 하지 못하는 건 아니다.(Attack의 기능은 '확장' 가능하지만 '수정' 가능하지 않다)



L : 리스코프 치환 법칙
이름은 어려운데(아마 SOLID를 정말로 맞추고 싶은가 봐요) 이건 '다형성'을 유지하는 것과 관련된 문제.
-자식 클래스는 부모 클래스가 들어가는 자리에 들어가도 아무런 문제가 없어야 한다.

-Weapon 자리에는 Sword, Spear, Bow, Gun, Cannon 등 어떤 자식 클래스가 들어오건 정상 작동하여야 한다.
-자식 클래스가 메서드를 오버라이딩하였어도 그 본질적인 의미가 달라져서는 안된다.
-Weapon.attack을 오버라이딩한 Sword.attack, Spear.attack, Bow.attack 등은 모두 Weapon.attack과 같은 역할, 즉 공격 역할을 해야 한다.
-이 함수가 공격이 아닌 부대의 공격 명령으로 바뀌어버렸다면, 문제가 발생할 수 있다.



I : Interface Separation Principle (인터페이스 분리의 원칙)
쓰지 않는 인터페이스는 들고 있지 않아야 한다.
-MapObject라는 클래스를 만들어 맵상에 새를 구현하려 한다. 이를 위해서 MapObject에 인터페이스 IMovable을 상속시켰다.
-맵에 있는 나무도 MapObject로 만들었지만 나무는 움직이지 않으니 IMovable 관련 메서드들은 아무 일도 안하게 하였다.

-이러면 이 클래스 외부에서는 나무도 움직일 수 있는 개체라 판단할 수 있다!
-MovableMapObject라는 MapObject의 상속개체를 만들고 거기에 IMovable을 부여하면 I원칙을 지킬 수 있다.




D : Dependency Inversion Principle(의존성 역전의 원칙)
토익 990이어도 뭔말인지 모를 영어
------------------------------------------------------------------------------------------------------
A. HIGH LEVEL MODULES SHOULD NOT DEPEND UPON LOW LEVEL MODULES. BOTH SHOULD DEPEND UPON ABSTRACTIONS.
B. ABSTRACTIONS SHOULD NOT DEPEND UPON DETAILS. DETAILS SHOULD DEPEND UPON ABSTRACTIONS
------------------------------------------------------------------------------------------------------
요약 : 상위 개체가 하위 개체에 의존성을 지녀서는 안된다. 모두 추상화된 기능에 의존해야 한다.


<저수준의 모듈에 고수준의 모듈이 의존해서는 안된다. 두 모듈은 추상화된 기능에 의존해야 한다.>
HIGH LEVEL MODULES SHOULD NOT DEPEND UPON LOW LEVEL MODULES. BOTH SHOULD DEPEND UPON ABSTRACTIONS.
-Weapon개체는 '공격할 수 있는 기구'이다. 이 기구가 내부적으로 어떤 일을 하는지에 상위 개체가 의존해서는 안된다.
-Character개체는 Weapon이 공격할 수 있다는 것만 알고 있다. 이 Weapon이 총알을 생성해서 발사하는지, 근접에서 휘두르는지는 Character는 모른다.
-Weapon 개체는 Character 개체가 자신의 Attack을 실행시킨다는 것만 안다. 언제, 어떤 명령 후에 실행시키는지는 모른다.

-Character는 추상화된 '공격'이라는 기능만을 사용해서 Weapon을 사용해야 하고,
-Weapon은 Character가 자신에게 Weapon 명령을 언제 내리건 즉시 '공격' 기능을 사용할 수 있어야 한다.


<추상화된 관념은 디테일에 의존해서는 안된다.디테일한 개념이 추상화된 개념에 의존해야 한다.>
-Gun은 Attack을 위해 많은 기능들(방아쇠가 당겨지고 공이로 총알 뒤를 쳐서 총알이 점화되어 총신을 지나 발사.....)을 수행해야 한다.
-하지만 '공격'이라는 기능이 그 세부과정에 영향을 받아 구현이 달라져서는 안된다.
-Gun은 오로지 Attack이라는 추상적인 관념을 수행하기 위한 세부사항을 시행할 뿐이며
-Attack이라는 결과는 내부에서 무슨 일이 일어나건 상관없이 진행되어야 한다.
-다시 말해 총이 내부에서 뭘 하건, 방아쇠를 당기면 발사되어야 한다. 그게 이루어지지 않는다면 '총'이라 할 수 없다.

-D원칙은 인터페이스를 통해서 쉽게 구현된다.
--Interface IAttackable을 상속받았다면 이 개체는 추상적인 기능 Attack을 구현할 것이다.
--개체가 Attack을 어떻게 구현하건 Attack은 같은 기능을 할 거라고 기대할 수 있다.